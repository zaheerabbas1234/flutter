import 'dart:math';

import 'package:flutter/material.dart';

void main() => runApp(const MainApp());

enum SeasonTheme { summer, winter, rainy }

class MainApp extends StatefulWidget {
  const MainApp({super.key});

  @override
  State<MainApp> createState() => _MainAppState();
}

class _MainAppState extends State<MainApp> with SingleTickerProviderStateMixin {
  SeasonTheme _currentTheme = SeasonTheme.summer;

  late final AnimationController _controller;

  @override
  void initState() {
    super.initState();

    _controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 4),
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  ThemeData getThemeData(SeasonTheme theme) {
    switch (theme) {
      case SeasonTheme.winter:
        return ThemeData(
          brightness: Brightness.dark,
          scaffoldBackgroundColor: Colors.black, // changed to black
          appBarTheme: const AppBarTheme(
            backgroundColor: Colors.grey, // darker app bar for contrast
            foregroundColor: Colors.white,
          ),
          colorScheme: const ColorScheme.dark(
            primary: Colors.lightBlueAccent,
            secondary: Colors.blueAccent,
            background: Colors.black,
            surface: Colors.grey,
            onPrimary: Colors.white,
            onSecondary: Colors.white,
            onBackground: Colors.white,
            onSurface: Colors.white,
          ),
          textTheme: const TextTheme(bodyLarge: TextStyle(color: Colors.white)),
        );

      case SeasonTheme.rainy:
        return ThemeData(
          brightness: Brightness.dark,
          scaffoldBackgroundColor: const Color(0xFF263238), // dark slate
          appBarTheme: const AppBarTheme(
            backgroundColor: Color(0xFF37474F),
            foregroundColor: Colors.lightBlueAccent,
          ),
          colorScheme: ColorScheme.dark(
            primary: const Color(0xFF80DEEA),
            secondary: const Color(0xFF4DD0E1),
            background: const Color(0xFF263238),
            surface: const Color(0xFF37474F),
            onPrimary: Colors.black87,
            onSecondary: Colors.black87,
            onBackground: const Color(0xFFB0BEC5),
            onSurface: const Color(0xFFB0BEC5),
          ),
          textTheme: const TextTheme(
            bodyLarge: TextStyle(color: Color(0xFFB0BEC5)),
          ),
        );

      case SeasonTheme.summer:
      default:
        return ThemeData(
          brightness: Brightness.light,
          scaffoldBackgroundColor: const Color(0xFFFFF9C4), // sunny yellow
          appBarTheme: const AppBarTheme(
            backgroundColor: Color(0xFFFFF176),
            foregroundColor: Colors.deepOrange,
          ),
          colorScheme: ColorScheme.light(
            primary: const Color(0xFFFFA000),
            secondary: const Color(0xFFFFD54F),
            background: const Color(0xFFFFF9C4),
            surface: const Color(0xFFFFF59D),
            onPrimary: Colors.white,
            onSecondary: Colors.white,
            onBackground: const Color(0xFFF57F17),
            onSurface: const Color(0xFFF57F17),
          ),
          textTheme: const TextTheme(
            bodyLarge: TextStyle(color: Color(0xFFF57F17)),
          ),
        );
    }
  }

  IconData getSeasonIcon(SeasonTheme theme) {
    switch (theme) {
      case SeasonTheme.summer:
        return Icons.wb_sunny;
      case SeasonTheme.winter:
        return Icons.ac_unit;
      case SeasonTheme.rainy:
        return Icons.beach_access; // umbrella icon
    }
  }

  @override
  Widget build(BuildContext context) {
    final themeData = getThemeData(_currentTheme);

    return MaterialApp(
      theme: themeData,
      home: Scaffold(
        appBar: AppBar(
          title: Text(
            _currentTheme.toString().split('.').last.toUpperCase() + ' Season',
          ),
        ),
        body: Stack(
          children: [
            // Background animation by season
            Positioned.fill(
              child: Builder(
                builder: (context) {
                  switch (_currentTheme) {
                    case SeasonTheme.summer:
                      return SummerBrightnessAnimation(controller: _controller);
                    case SeasonTheme.winter:
                      return SnowfallAnimation(controller: _controller);
                    case SeasonTheme.rainy:
                      return RainfallAnimation(controller: _controller);
                  }
                },
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                children: <Widget>[
                  AnimatedSwitcher(
                    duration: const Duration(milliseconds: 600),
                    transitionBuilder: (child, animation) {
                      return FadeTransition(opacity: animation, child: child);
                    },
                    child: OutlinedButton.icon(
                      key: ValueKey(_currentTheme),
                      onPressed: () {},
                      label: const Text('Button'),
                      icon: Icon(
                        getSeasonIcon(_currentTheme),
                        color: themeData.colorScheme.primary,
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  DropdownButton<SeasonTheme>(
                    value: _currentTheme,
                    onChanged: (SeasonTheme? newTheme) {
                      if (newTheme != null) {
                        setState(() {
                          _currentTheme = newTheme;
                        });
                      }
                    },
                    items: SeasonTheme.values.map((SeasonTheme theme) {
                      return DropdownMenuItem<SeasonTheme>(
                        value: theme,
                        child: Text(
                          theme.toString().split('.').last.toUpperCase(),
                        ),
                      );
                    }).toList(),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Summer: Pulsating bright overlay effect
class SummerBrightnessAnimation extends AnimatedWidget {
  const SummerBrightnessAnimation({
    required Animation<double> controller,
    super.key,
  }) : super(listenable: controller);

  @override
  Widget build(BuildContext context) {
    final animation = listenable as Animation<double>;

    return IgnorePointer(
      ignoring: true,
      child: Container(
        color: Colors.yellow.withOpacity(0.2 + 0.3 * animation.value),
      ),
    );
  }
}

/// Winter: Falling snowflakes effect
class SnowfallAnimation extends StatefulWidget {
  final AnimationController controller;

  const SnowfallAnimation({required this.controller, super.key});

  @override
  _SnowfallAnimationState createState() => _SnowfallAnimationState();
}

class _SnowfallAnimationState extends State<SnowfallAnimation> {
  final int snowflakeCount = 100;
  late List<_Snowflake> snowflakes;
  late Animation<double> animation;

  @override
  void initState() {
    super.initState();
    final random = Random();
    snowflakes = List.generate(
      snowflakeCount,
      (_) => _Snowflake(
        x: random.nextDouble(),
        y: random.nextDouble(),
        radius: random.nextDouble() * 3 + 1,
        speed: random.nextDouble() * 0.002 + 0.001,
      ),
    );
    animation = widget.controller;
    animation.addListener(() {
      setState(() {
        for (var flake in snowflakes) {
          flake.y += flake.speed;
          if (flake.y > 1) {
            flake.y = 0;
          }
        }
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return CustomPaint(painter: _SnowPainter(snowflakes), child: Container());
  }
}

class _Snowflake {
  double x;
  double y;
  final double radius;
  final double speed;

  _Snowflake({
    required this.x,
    required this.y,
    required this.radius,
    required this.speed,
  });
}

class _SnowPainter extends CustomPainter {
  final List<_Snowflake> snowflakes;

  _SnowPainter(this.snowflakes);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = Colors.white.withOpacity(0.7);

    for (var flake in snowflakes) {
      final dx = flake.x * size.width;
      final dy = flake.y * size.height;
      canvas.drawCircle(Offset(dx, dy), flake.radius, paint);
    }
  }

  @override
  bool shouldRepaint(covariant _SnowPainter oldDelegate) => true;
}

/// Rainy: Falling raindrops effect
class RainfallAnimation extends StatefulWidget {
  final AnimationController controller;

  const RainfallAnimation({required this.controller, super.key});

  @override
  _RainfallAnimationState createState() => _RainfallAnimationState();
}

class _RainfallAnimationState extends State<RainfallAnimation> {
  final int dropCount = 150;
  late List<_Raindrop> raindrops;
  late Animation<double> animation;

  @override
  void initState() {
    super.initState();
    final random = Random();
    raindrops = List.generate(
      dropCount,
      (_) => _Raindrop(
        x: random.nextDouble(),
        y: random.nextDouble(),
        length: random.nextDouble() * 20 + 10,
        speed: random.nextDouble() * 0.01 + 0.005,
        thickness: random.nextDouble() * 1.5 + 0.5,
      ),
    );
    animation = widget.controller;
    animation.addListener(() {
      setState(() {
        for (var drop in raindrops) {
          drop.y += drop.speed;
          if (drop.y > 1) {
            drop.y = 0;
          }
        }
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return CustomPaint(painter: _RainPainter(raindrops), child: Container());
  }
}

class _Raindrop {
  double x;
  double y;
  final double length;
  final double speed;
  final double thickness;

  _Raindrop({
    required this.x,
    required this.y,
    required this.length,
    required this.speed,
    required this.thickness,
  });
}

class _RainPainter extends CustomPainter {
  final List<_Raindrop> raindrops;

  _RainPainter(this.raindrops);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.lightBlueAccent.withOpacity(0.6)
      ..strokeCap = StrokeCap.round;

    for (var drop in raindrops) {
      final start = Offset(drop.x * size.width, drop.y * size.height);
      final end = Offset(
        drop.x * size.width,
        drop.y * size.height + drop.length,
      );
      paint.strokeWidth = drop.thickness;
      canvas.drawLine(start, end, paint);
    }
  }

  @override
  bool shouldRepaint(covariant _RainPainter oldDelegate) => true;
}

